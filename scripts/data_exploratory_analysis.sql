/*
This script analyses report on customer  and product behaviour, aggregating  total revenue, cost and product quantity.
it also analyses the YoY growth of both customers and products, segments customer purchase power
And segments customers into VIP, Regular or New customers.
It measures the average monthy revenue generated as well as aveage cost and much more insights generated
*/

----aggregating total sales, quantity of products and total no of customers generated by year
SELECT 
    date_trunc(year, order_date) AS order_date,
    SUM(sales_amount) AS total_sales,
    SUM(quantity) AS total_quantity,
    COUNT(DISTINCT customer_key)
FROM fact_sales
GROUP BY date_trunc(year, order_date)
ORDER BY date_trunc(year, order_date)


-----calculating the Total Sales By Month
-----And the running Total Of Sales Over Time
WITH sales_by_month AS
(
SELECT 
    date_trunc(month, order_date)AS order_date,
    SUM(sales_amount) AS total_sales,
    ROUND(AVG(price),2) AS average_price
FROM fact_sales
GROUP BY  date_trunc(month, order_date)

)
SELECT 
   order_date,
    sum(total_sales) OVER (PARTITION BY order_date ORDER BY order_date) cumulative_sales,
     avg(average_price) OVER (PARTITION BY order_date ORDER BY order_date) cumulative_average
FROM sales_by_month


/*
Analyzing the yearly performance of products 
by comparing each product's sales to both its average sales performance and the previous year's sales 
*/
WITH yealry_sales_performance AS 
(
SELECT 
    YEAR(order_date) AS order_year,
    p.product_name AS product_name,
    SUM(sales_amount) AS current_sales,  
FROM fact_sales s
LEFT JOIN dim_products p
ON s.product_key =p.product_key
GROUP BY  year(order_date), product_name
)
SELECT 
     order_year,
     product_name,
     current_sales, 
     AVG(current_sales) OVER(PARTITION BY product_name) avg_sales,
     current_sales - AVG(current_sales) OVER(PARTITION BY product_name) as diff_avg,
     CASE WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name)> 0 THEN 'Above avg' 
          WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) <0 THEN 'Below Avg'
     ELSE 'Avg'
     END as Avg_change,
    ----YOY Analysis------
    LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) as previous_year,
     current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) as previous_year_diff,
     CASE WHEN  current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) > 0 THEN 'Increase' 
            WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) <0 THEN 'Decrease'
         ELSE 'No change' 
     END AS previousYear_diff     
 FROM yealry_sales_performance
 ORDER BY product_name, order_year


 ----which product category contributes the most to the overall sales
WITH category_contributions AS
(
 SELECT 
     p.category AS category,
     sum(sales_amount) AS total_sales
 FROM fact_sales f
 LEFT JOIN dim_products p
 ON f.product_key = p.product_key
 GROUP BY p.category
 )
 select 
    category,
    total_sales,
    SUM(total_sales) OVER() AS rolling_total,
    concat(round(total_sales / sum(total_sales) OVER()  * 100,2),'%')  AS percentage_cntribution
FROM category_contributions
ORDER BY percentage_cntribution DESC;

--segment products into cost ranges and count how many products fall into these segments
WITH prod_segment AS 
(
SELECT 
    product_key,
    product_name,
    cost,
    CASE WHEN cost <100 THEN 'Below 100'
        WHEN cost BETWEEN 100 AND 500 THEN '100-500'
        WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
        ELSE 'Above 1000'
    END AS cost_range
FROM dim_products
)
SELECT 
    cost_range,
    count(product_key) as total_products
FROM prod_segment
GROUP BY cost_range
ORDER BY total_products DESC;

/*--Grouping customers into segments according to their spending behaviour
- VIP Custoomers are those with atleat 12 months of spending history and spending more than 5,000
-Regular customers are those with atleast 12 months of spending history and spending 5000 or less
-New customers have lifespan less than 12 months
-find how many customers are in each segment?*/

WITH customer_spending AS 
(
SELECT 
    c.customer_key AS customer,
   sum(sales_amount) AS total_spending,
   min(order_date) AS first_order_date,
   max(order_date) AS last_order_date,
   datediff(month,min(order_date), max(order_date)) AS lifespan
FROM fact_sales f
LEFT JOIN dim_customers c
ON f.customer_key = c.customer_key
GROUP BY c.customer_key
)
SELECT 
    count(customer) AS total_customers,
    CASE WHEN lifespan >= 12 AND total_spending >5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_spending <=5000 THEN 'Regular'
        WHEN lifespan < 12 THEN 'New'
        ELSE 'Others'
        END AS customer_segment
FROM customer_spending
GROUP BY customer_segment
ORDER BY total_customers desc;


-------------------------------------CUSTOMER REPORT------------------------------------------------------------

/*This Report Consolidates Key Customer Metrics And Behaviours
Highlight:
--Gather essential fields such as names, ages, and transaction details.

--Segment Customers into categories (VIP, Regular, New) and age groups.

--Aggregate customer-level metrics:
    -total orders
    -total sales
    -total quantity purchased
    -total products
    -lifespan (in months)
    
--Calculate valuable KPIs:
    -recency (months since last order)
    -average monthly spend
    */

----------------------------------------------------------------------------------------------------------------------
CREATE VIEW gold.customer_report AS
(
WITH base_query AS 
(
SELECT 
    f.order_number,
    f.product_key,
    f.order_date as order_date,
    f.sales_amount as sales,
    f.quantity,c.customer_key,
    c.customer_number,
    concat(c.first_name,' ', c.last_name) as customer_name,
   datediff(year,c.birthdate, current_date()) as Age,
FROM fact_sales f
LEFT JOIN dim_customers c
ON f.customer_key =  c.customer_key
WHERE order_date IS NOT NULL
),

 customer_agregation AS
--Customer aggregations: summarizes key metrics at the customer level
(
SELECT
   customer_key, 
   customer_number,
   customer_name,
   Age,
   COUNT(distinct order_number)AS total_orders,
   SUM(quantity) AS total_quantity,
   SUM(sales)AS total_sales,
   COUNT(product_key) AS total_products,
   MIN(order_date) as first_order_date,
   MAX(order_date) AS last_order_date,
   datediff(month,MIN(order_date),MAX(order_date)) AS lifespan,
FROM base_query
GROUP BY  customer_key, 
   customer_number,
   customer_name,
   Age
)

SELECT 
   customer_key, 
   customer_number,
   customer_name,
   Age,
   CASE
        WHEN age < 20 THEN 'U NDER 20'
        WHEN age BETWEEN 20 AND 29 THEN '20-29'
        WHEN age BETWEEN 30 AND 39 THEN '30-39'
        WHEN age BETWEEN 40 AND 49 THEN '40-49'
   ELSE  '50 and Above'
   END AS age_bracket,
    
   CASE 
    WHEN lifespan >= 12 AND total_sales >5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_sales <=5000 THEN 'Regular'
        WHEN lifespan < 12 THEN 'New'
        ELSE 'Others'
    END AS customer_segment, 
   first_order_date,
   last_order_date,
   datediff(month,first_order_date,last_order_date)AS recency,
   total_orders,
   total_quantity,
   total_products,
   lifespan,
----compute average order value-(AOV)---
CASE 
    WHEN total_sales = 0 THEN 0
ELSE ROUND(total_sales/total_orders,2) 
END AS avg_order_value,
----compute average monthly spend----
CASE 
    WHEN lifespan = 0 THEN total_sales
ELSE ROUND(total_sales/lifespan,2) 
END AS avg_monthly_spend

FROM customer_agregation
   
SELECT * FROM gold.customer_report

/*---------------------------Product Report----------------------------------------------------------------
Purpose:
    -This report consolidates key product metrics and behaviours.
    
Highlights:
1. Gather essential fields such as product name, category, subcategory, and cost.

2. Segment products by revenue to identify High-Performers, Mid-Performers or Low-Performers.

3. Aggregate product-level metrics:
    -total orders
    -total sales
    -total quantity sold
    -totalcustomers(unique)
    -lifespan (in months)
    
4. Calculate valuable KPIs:
    -recency (months since last sale)
    -average order revenue (AOR)
    -average monthly revenue
---------------------------------------------------------------------------------------------------------------------*/
CREATE  VIEW gold.product_report AS
WITH product_details AS 
(
SELECT 
    f.customer_key as customers,
    f.order_number,
    f.product_key,
    f.order_date as order_date,
    p.start_date as prod_start,
    f.sales_amount as sales,
    p.cost,
    f.quantity,
    p.product_name AS product_name,
    p.category AS category,
    p.subcategory AS subcategory,
    f.price,
    f.quantity * f.price AS revenue,
    f.sales_amount - p.cost as profit       
FROM fact_sales f
LEFT JOIN dim_products p
ON f.product_key = p.product_key
WHERE order_date IS NOT NULL
),
product_aggregation AS
(
SELECT 
    COUNT(distinct customers) as total_customers,
    product_name,
    category,
    count(order_number) AS total_orders,
    count(distinct product_key) as total_products,
    MIN(order_date) as first_prod_order_date,
    MAX(order_date) as last_prod_order_date,
    datediff(month,MIN(order_date), MAX(order_date)) as product_lifespan,
    SUM(revenue) as total_revenue,
    SUM(quantity) as total_quantity,
    SUM(cost) as total_cost
FROM product_details
GROUP BY  product_name, category  
)
SELECT
    total_customers,
    total_orders,
    product_name,
    category,
 --Segment products by revenue to identify High-Performers, Mid-Performers, or Low-Performers
     CASE
        WHEN total_revenue < 10000 THEN 'Low Performer'
        WHEN total_revenue Between  10000 AND 100000 THEN 'Mid-Performer' 
        WHEN total_revenue >100000 THEN 'High-Performer'
    END AS product_performance,
--recency (months since last sale)
    datediff(month,last_prod_order_date, current_date()) as prod_recency,
 --average order revenue (AOR)
    CASE
        WHEN total_orders = 0 THEN 0
        ELSE ROUND(total_revenue/ total_orders,2)  
    END AS avg_order_revenue,
--average monthly revenue
    CASE 
      WHEN prod_recency = 0 THEN total_revenue
   ELSE ROUND(total_revenue/prod_recency,2) 
   END AS avg_monthly_spend
FROM product_aggregation 
